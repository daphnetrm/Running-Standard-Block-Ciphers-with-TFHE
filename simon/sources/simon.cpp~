#include <stdio.h>
#include <stdlib.h>
#include "simon.h"
#include "tables.h"
#include "bootstrapping.h"


#define f64(x) ((ROTL64(x,1) & ROTL64(x,8)) ^ ROTL64(x,2))
#define R64x2(x,y,k1,k2) (y^=f64(x), y^=k1, x^=f64(y), x^=k2)



//applique le AND clair-chiffré bit à bit et renvoie le résultat dans result
void and_fhe (vector <LweSample*> &result,
	      vector <LweSample*> &b,
	      TFheGateBootstrappingSecretKeySet* gk,
	      BaseBKeySwitchKey* ks_key,
	      word8 tab[16]
	      ) {
  deref_single_boot(result, gk, b, ks_key, 0,0, tab);
}

void and_64_fhe(vector <LweSample*> result[8],
	      vector <LweSample*> b[8],
	      TFheGateBootstrappingSecretKeySet* gk,
	      BaseBKeySwitchKey* ks_key
	      ) {
  for(int i=0; i<8; i++)
    AND_fhe(result[i], b[i], gk, ks_key);
}

void xor_64_fhe(vector <LweSample*> result[8],
	      vector <LweSample*> b[8],
	      TFheGateBootstrappingSecretKeySet* gk,
	      BaseBKeySwitchKey* ks_key
	      ) {
  for(int i=0; i<8; i++)
    XOR_fhe(result[i], b[i], gk, ks_key);
}


//left circular shift of one byte
void shift_8_fhe(vector <LweSample*> res[8], vector <LweSample*> a[8], TFheGateBootstrappingSecretKeySet* gk, BaseBKeySwitchKey* ks_key){
  for(int i=0; i<8; i++){
    lweCopy(res[i][0], a[(i+1)%8][0], gk->lwe_key->params);
    lweCopy(res[i][1], a[(i+1)%8][1], gk->lwe_key->params);
  }
}


//left circular shift of one bit
void shift_1_fhe(vector <LweSample*> res[8], vector <LweSample*> a[8], TFheGateBootstrappingSecretKeySet* gk, BaseBKeySwitchKey* ks_key){
  vector<LweSample*> tmp, lsb;
  tmp.push_back(new_LweSample(gk->lwe_key->params));
  tmp.push_back(new_LweSample(gk->lwe_key->params));
  lsb.push_back(new_LweSample(gk->lwe_key->params));
  and_fhe(lsb,a[0], gk, ks_key, and_8);
  for(int i=0; i<7; i++){
    deref_single_boot(tmp, gk, a[i], ks_key, 1, 0, and_8);
    deref_single_boot(tmp, gk, a[i+1], ks_key, 0, 1, and_8);
    deref_single_boot(res[i], gk, a[i], ks_key, 0, 0, shift_1);
    deref_single_boot(res[i], gk, a[i], ks_key, 1, 1, shift_1);
    XOR_fhe(res[i], tmp, gk, ks_key);
  }
  lweCopy(tmp[1],lsb[0], gk->lwe_key->params);
  deref_single_boot(tmp, gk, a[7], ks_key, 1, 0, and_8);
  deref_single_boot(res[7], gk, a[7], ks_key, 0, 0, shift_1);
  deref_single_boot(res[7], gk, a[7], ks_key, 1, 1, shift_1);
  XOR_fhe(res[7], tmp, gk, ks_key);
}




void round_fhe(vector<LweSample*> x[8], vector<LweSample*> y[8], vector<LweSample*> a_shift_1[8], vector<LweSample*> a_shift_8[8], vector<LweSample*> rcki[8], TFheGateBootstrappingSecretKeySet* gk, BaseBKeySwitchKey* ks_key){
  shift_1_fhe(a_shift_1, x, gk, ks_key);
  shift_8_fhe(a_shift_8, x, gk, ks_key);
  and_64_fhe(a_shift_8, a_shift_1, gk, ks_key);
  xor_64_fhe(a_shift_8, y, gk, ks_key);
  shift_1_fhe(a_shift_1, x, gk, ks_key);
  xor_64_fhe(a_shift_8, a_shift_1, gk, ks_key);
  xor_64_fhe(a_shift_8, rcki, gk, ks_key);

  /* then swap x and y*/
   for(int i=0; i<8; i++){
    lweCopy(y[i][0], x[i][0], gk->lwe_key->params);
    lweCopy(y[i][1], x[i][1], gk->lwe_key->params);
    
    lweCopy(x[i][0], a_shift_8[i][0], gk->lwe_key->params);
    lweCopy(x[i][1], a_shift_8[i][1], gk->lwe_key->params);
  }
}




void SimonKeySchedule(u64 K[],u64 rk[]){
  u64 i,B=K[1],A=K[0];
  u64 c=0xfffffffffffffffcLL, z=0x7369f885192c0ef5LL;
  for(i=0;i<64;){
    rk[i++]=A; A^=c^(z&1)^ROTR64(B,3)^ROTR64(B,4); z>>=1;
    rk[i++]=B; B^=c^(z&1)^ROTR64(A,3)^ROTR64(A,4); z>>=1;
  }
  rk[64]=A; A^=c^1^ROTR64(B,3)^ROTR64(B,4);
  rk[65]=B; B^=c^0^ROTR64(A,3)^ROTR64(A,4);
  rk[66]=A; rk[67]=B;
}


void encrypt_fhe(vector<LweSample*> x[8], vector<LweSample*> y[8], vector<LweSample*> rcki[68][8], TFheGateBootstrappingSecretKeySet* gk, BaseBKeySwitchKey* ks_key){
   vector<LweSample*> a_shift_1[8], a_shift_8[8];
  for(int i=0; i<8; i++){
    a_shift_1[i].push_back(new_LweSample(gk->lwe_key->params));
    a_shift_1[i].push_back(new_LweSample(gk->lwe_key->params));
    lweCopy(a_shift_1[i][0], x[i][0], gk->lwe_key->params);
    lweCopy(a_shift_1[i][1], x[i][1], gk->lwe_key->params);
    
    a_shift_8[i].push_back(new_LweSample(gk->lwe_key->params));
    a_shift_8[i].push_back(new_LweSample(gk->lwe_key->params));
    lweCopy(a_shift_8[i][0], x[i][0], gk->lwe_key->params);
    lweCopy(a_shift_8[i][1], x[i][1], gk->lwe_key->params);
  }
  for(int i=0; i<68; i++)
    round_fhe(x, y, a_shift_1, a_shift_8, rcki[i], gk, ks_key);
}


void SimonEncrypt(u64 Pt[],u64 Ct[],u64 rk[]){
  u64 i;
  Ct[0]=Pt[0]; Ct[1]=Pt[1];
  for(i=0;i<68;i+=2) R64x2(Ct[1],Ct[0],rk[i],rk[i+1]);
}


void SimonDecrypt(u64 Pt[],u64 Ct[],u64 rk[]){
  int i;
  Pt[0]=Ct[0]; Pt[1]=Ct[1];
  for(i=67;i>=0;i-=2) R64x2(Pt[0],Pt[1],rk[i],rk[i-1]);
}
